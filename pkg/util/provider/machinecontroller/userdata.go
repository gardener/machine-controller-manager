// SPDX-FileCopyrightText: 2024 SAP SE or an SAP affiliate company and Gardener contributors
//
// SPDX-License-Identifier: Apache-2.0

package controller

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"math/big"
	"net/url"
	"strings"
	"time"

	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	bootstraptokenapi "k8s.io/cluster-bootstrap/token/api"
	bootstraptokenutil "k8s.io/cluster-bootstrap/token/util"
	"k8s.io/klog/v2"

	"github.com/gardener/machine-controller-manager/pkg/apis/machine/v1alpha1"
)

const (
	bootstrapTokenPlaceholder = "<<BOOTSTRAP_TOKEN>>"
	machineNamePlaceholder    = "<<MACHINE_NAME>>"
)

var (
	// urlEncodedBootstrapTokenPlaceholder is a bootstrapTokenPlaceholder that can for instance occur in ignition userdata format
	urlEncodedBootstrapTokenPlaceholder = url.QueryEscape(bootstrapTokenPlaceholder)
	// urlEncodedMachineNamePlaceholder is a machineNamePlaceholder that can for instance occur in ignition userdata format
	urlEncodedMachineNamePlaceholder = url.QueryEscape(machineNamePlaceholder)
)

func (c *controller) addBootstrapTokenToUserData(ctx context.Context, machine *v1alpha1.Machine, secret *corev1.Secret) error {
	var (
		userDataB []byte
		userDataS string
		exists    bool
	)

	if userDataB, exists = secret.Data["userData"]; !exists {
		// If userData key is not founds
		return fmt.Errorf("userdata field not found in secret for machine %q", machine.Name)
	}
	userDataS = string(userDataB)

	klog.V(4).Infof("Creating bootstrap token!")
	bootstrapTokenSecret, err := c.getBootstrapTokenOrCreateIfNotExist(ctx, machine)
	if err != nil {
		return err
	}
	token := bootstraptokenutil.TokenFromIDAndSecret(
		string(bootstrapTokenSecret.Data[bootstraptokenapi.BootstrapTokenIDKey]),
		string(bootstrapTokenSecret.Data[bootstraptokenapi.BootstrapTokenSecretKey]),
	)

	if strings.Contains(userDataS, bootstrapTokenPlaceholder) {
		klog.V(4).Infof("replacing placeholder %s with %s in user-data!", bootstrapTokenPlaceholder, token)
		userDataS = strings.ReplaceAll(userDataS, bootstrapTokenPlaceholder, token)
	} else if strings.Contains(userDataS, urlEncodedBootstrapTokenPlaceholder) {
		klog.V(4).Infof("replacing url encoded placeholder %s with %s in user-data!", urlEncodedBootstrapTokenPlaceholder, url.QueryEscape(token))
		userDataS = strings.ReplaceAll(userDataS, urlEncodedBootstrapTokenPlaceholder, url.QueryEscape(token))
	} else {
		klog.Warningf("no bootstrap token placeholder found in user-data, nothing to replace! Without bootstrap token , node won't join.")
	}

	secret.Data["userData"] = []byte(userDataS)

	return nil
}

func (c *controller) addMachineNameToUserData(machine *v1alpha1.Machine, secret *corev1.Secret) error {
	var (
		userDataB []byte
		userDataS string
		exists    bool
	)

	if userDataB, exists = secret.Data["userData"]; !exists {
		// If userData key is not founds
		return fmt.Errorf("userdata field not found in secret for machine %q", machine.Name)
	}
	userDataS = string(userDataB)

	if strings.Contains(userDataS, machineNamePlaceholder) {
		klog.V(4).Infof("replacing placeholder %s with %s in user-data!", machineNamePlaceholder, machine.Name)
		userDataS = strings.ReplaceAll(userDataS, machineNamePlaceholder, machine.Name)
	} else if strings.Contains(userDataS, urlEncodedMachineNamePlaceholder) {
		klog.V(4).Infof("replacing url encoded placeholder %s with %s in user-data!", urlEncodedMachineNamePlaceholder, url.QueryEscape(machine.Name))
		userDataS = strings.ReplaceAll(userDataS, urlEncodedMachineNamePlaceholder, url.QueryEscape(machine.Name))
	} else {
		klog.Info("no machine name placeholder found in user-data, nothing to replace! Without machine name , node won't join if node-agent-authorizer is enabled.")
	}

	secret.Data["userData"] = []byte(userDataS)

	return nil
}

func (c *controller) getBootstrapTokenOrCreateIfNotExist(ctx context.Context, machine *v1alpha1.Machine) (secret *corev1.Secret, err error) {
	tokenID, secretName := getTokenIDAndSecretName(machine.Name)

	secret, err = c.targetCoreClient.CoreV1().Secrets(metav1.NamespaceSystem).Get(ctx, secretName, metav1.GetOptions{})
	if err != nil {
		if apierrors.IsNotFound(err) {
			bootstrapTokenSecretKey, err := generateRandomStringFromCharset(16, "0123456789abcdefghijklmnopqrstuvwxyz")
			if err != nil {
				return nil, err
			}
			data := map[string][]byte{
				bootstraptokenapi.BootstrapTokenDescriptionKey:      []byte(fmt.Sprintf("A bootstrap token for machine %q generated by MachineControllerManager.", machine.Name)),
				bootstraptokenapi.BootstrapTokenIDKey:               []byte(tokenID),
				bootstraptokenapi.BootstrapTokenSecretKey:           []byte(bootstrapTokenSecretKey),
				bootstraptokenapi.BootstrapTokenExpirationKey:       []byte(metav1.Now().Add(c.getEffectiveCreationTimeout(machine).Duration).Format(time.RFC3339)),
				bootstraptokenapi.BootstrapTokenUsageAuthentication: []byte("true"),
				bootstraptokenapi.BootstrapTokenUsageSigningKey:     []byte("true"),
				bootstraptokenapi.BootstrapTokenExtraGroupsKey:      []byte(c.bootstrapTokenAuthExtraGroups),
			}

			secret = &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      secretName,
					Namespace: metav1.NamespaceSystem,
				},
				Type: bootstraptokenapi.SecretTypeBootstrapToken,
				Data: data,
			}

			return c.targetCoreClient.CoreV1().Secrets(metav1.NamespaceSystem).Create(ctx, secret, metav1.CreateOptions{})
		}
		return nil, err
	}

	return secret, nil
}

func (c *controller) deleteBootstrapToken(ctx context.Context, machineName string) error {
	_, secretName := getTokenIDAndSecretName(machineName)
	err := c.targetCoreClient.CoreV1().Secrets(metav1.NamespaceSystem).Delete(ctx, secretName, metav1.DeleteOptions{})
	if err != nil && apierrors.IsNotFound(err) {
		// Object no longer exists and has been deleted
		return nil
	}
	return err
}

// generateRandomStringFromCharset generates a cryptographically secure random string of the specified length <n>.
// The set of allowed characters can be specified. Returns error if there was a problem during the random generation.
func generateRandomStringFromCharset(n int, allowedCharacters string) (string, error) {
	output := make([]byte, n)
	maximum := new(big.Int).SetInt64(int64(len(allowedCharacters)))
	for i := range output {
		randomCharacter, err := rand.Int(rand.Reader, maximum)
		if err != nil {
			return "", err
		}
		output[i] = allowedCharacters[randomCharacter.Int64()]
	}
	return string(output), nil
}

func getTokenIDAndSecretName(machineName string) (string, string) {
	tokenID := hex.EncodeToString([]byte(machineName)[len(machineName)-5:])[:6]
	secretName := bootstraptokenutil.BootstrapTokenSecretName(tokenID)
	return tokenID, secretName
}
